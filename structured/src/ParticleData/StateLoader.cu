#include "ParticleData/StateLoader.cuh"

#include "Utils/Preprocessor/DataAccess.cuh"

namespace uammd{
namespace structured{

void stateLoader(ParticleData* pd,DataEntry& data){

    std::vector<std::string>   labels = data.getLabels();
    std::map<std::string,bool> isLabelLoaded;

    for(auto lbl:labels){
        isLabelLoaded[lbl] = false;
    }

    int N = pd->getNumParticles();

    //Id and position are compulsory

    std::vector<int> id2index(N);
    //Check id label is present
    if(std::find(labels.begin(), labels.end(), "id") == labels.end()){
        System::log<System::CRITICAL>("[StateLoader] Label 'id' not found in the state file.");
    } else {
        //Load id
        std::vector<int>  id = data.getData<int>("id");

        //Check there are N ids
        if(id.size() != N){
            System::log<System::CRITICAL>("[StateLoader] Number of ids in the state file does not match the number of particles.");
        }

        //Check id is unique
        std::sort(id.begin(), id.end());
        if(std::adjacent_find(id.begin(), id.end()) != id.end()){
            System::log<System::CRITICAL>("[StateLoader] Ids are not unique.");
        }

        //Check id is in the range [0,N-1]
        if(id[0] != 0 || id[N-1] != N-1){
            System::log<System::CRITICAL>("[StateLoader] Ids are not in the range [0,N-1].");
        }

        //Load id and create id2index
        System::log<System::MESSAGE>("[StateLoader] Loading property \"id\".");
        auto pId = pd->getId(access::location::cpu, access::mode::write);
        for(int i = 0; i < N; i++){
            pId[i] = id[i];
            id2index[id[i]] = i;
        }

        isLabelLoaded["id"] = true;
    }

    //Check position label is present
    if(std::find(labels.begin(), labels.end(), "position") == labels.end()){
        System::log<System::CRITICAL>("[StateLoader] Label 'position' not found in the state file.");
    } else {
        std::vector<real3> position = data.getData<real3>("position");

        //Load position
        System::log<System::MESSAGE>("[StateLoader] Loading property \"position\".");
        auto pPosition = pd->getPos(access::location::cpu, access::mode::write);
        for(int i = 0; i < N; i++){
            pPosition[i] = make_real4(position[id2index[i]],-1); //Note that the fourth component is the type, which is not loaded
        }

        isLabelLoaded["position"] = true;

    }

    // Autogenerated property loading
    #define LOAD_PROPERTIES_IMPL(NAME, name, type) \
    if (std::find(labels.begin(), labels.end(), #name) != labels.end()) { \
        System::log<System::MESSAGE>("[StateLoader] Loading property: %s", std::string(#name).c_str()); \
        std::vector<type> prop = data.getData<type>(#name); \
        auto p##NAME = pd->get##NAME(access::location::cpu, access::mode::write); \
        for (int i = 0; i < N; i++) { \
            p##NAME[i] = prop[id2index[i]]; \
        } \
        isLabelLoaded[#name] = true; \
    }

    #define LOAD_PROPERTIES_EVAL(NAME, name, type) LOAD_PROPERTIES_IMPL(NAME, name, type)

    #define LOAD_PROPERTIES(r, data, seq) \
        LOAD_PROPERTIES_EVAL(__DATA_CAPS__(seq), __DATA_NAME__(seq), __DATA_TYPE__(seq))

    __MACRO_OVER_STATE__(LOAD_PROPERTIES)

    //Check all labels are loaded
    for(auto lbl:labels){
        if(!isLabelLoaded[lbl]){
            System::log<System::CRITICAL>("[StateLoader] \" %s \" is a not valid state property.",lbl.c_str());
        }
    }

}

void updateState(ParticleData* pd,DataEntry& data){
    System::log<System::DEBUG>("[StateLoader] Updating state.");

    std::vector<std::string> labels = data.getLabels();
    std::vector<std::string> toUpdate;


    // Autogenerated property checking
    #define CHECK_PROPERTY_IMPL(NAME, name, type) \
    if (pd->is##NAME##Allocated()) { \
        toUpdate.push_back(#name); \
    }

    #define CHECK_PROPERTY_EVAL(NAME, name, type) CHECK_PROPERTY_IMPL(NAME, name, type)

    #define CHECK_PROPERTY(r, data, seq) \
        CHECK_PROPERTY_EVAL(__DATA_CAPS__(seq), __DATA_NAME__(seq), __DATA_TYPE__(seq))

    __MACRO_OVER_STATE__(CHECK_PROPERTY)

    //Remove all toUpdate labels that are present in labels
    for(auto lbl : labels){
        toUpdate.erase(std::remove(toUpdate.begin(), toUpdate.end(), lbl), toUpdate.end());
    }

    auto sortedIndex = pd->getIdOrderedIndices(access::location::cpu);

    //Add all toUpdate labels to labels
    labels.insert(labels.end(), toUpdate.begin(), toUpdate.end());
    //Set labels
    data.setLabels(labels);
    for(int i = 0; i < labels.size(); i++){
        std::string lbl = labels[i];

        if        (lbl == "id"){
            auto pId = pd->getId(access::location::cpu, access::mode::read);
            for(int id=0;id<pd->getNumParticles();id++){
                int index = sortedIndex[id];
                data.setData(id, i, pId[index]);
            }
        } else if (lbl == "position"){
            auto pPosition = pd->getPos(access::location::cpu, access::mode::read);
            for(int id=0;id<pd->getNumParticles();id++){
                int index = sortedIndex[id];
                data.setData(id, i, make_real3(pPosition[index]));
            }
        } else {

            // Autogenerated property updating
            #define UPDATE_PROPERTY_IMPL(NAME, name, type) \
            if (lbl == #name) { \
                auto p##NAME = pd->get##NAME(access::location::cpu, access::mode::read); \
                for (int id = 0; id < pd->getNumParticles(); id++) { \
                    int index = sortedIndex[id]; \
                    data.setData(id, i, p##NAME[index]); \
                } \
            }

            #define UPDATE_PROPERTY_EVAL(NAME, name, type) UPDATE_PROPERTY_IMPL(NAME, name, type)

            #define UPDATE_PROPERTY(r, data, seq) \
                UPDATE_PROPERTY_EVAL(__DATA_CAPS__(seq), __DATA_NAME__(seq), __DATA_TYPE__(seq))

            __MACRO_OVER_STATE__(UPDATE_PROPERTY)

        }
    }

}

#undef LOAD_PROPERTIES_IMPL
#undef LOAD_PROPERTIES_EVAL
#undef LOAD_PROPERTIES

#undef CHECK_PROPERTY_IMPL
#undef CHECK_PROPERTY_EVAL
#undef CHECK_PROPERTY

#undef UPDATE_PROPERTY_IMPL
#undef UPDATE_PROPERTY_EVAL
#undef UPDATE_PROPERTY

}}
